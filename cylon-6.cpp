#include <circle/logger.h>
#include <circle/debug.h>
#include <circle/util.h>
#include <circle/pwmoutput.h>
#include <assert.h>
#include "cylon-6.h"

u8 edid[] = {	 // the real edid data from one HP Z27 4K monitor
		0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x22, 0x0e, 0x36, 0x35, 0x00, 0x00, 0x00, 0x00,
		0x12, 0x1c, 0x01, 0x03, 0x80, 0x3c, 0x22, 0x78, 0x3e, 0xee, 0x95, 0xa3, 0x54, 0x4c, 0x99, 0x26,
		0x0f, 0x50, 0x54, 0xa1, 0x08, 0x00, 0xd1, 0xc0, 0xa9, 0xc0, 0x81, 0xc0, 0xd1, 0x00, 0xb3, 0x00,
		0x95, 0x00, 0x81, 0x00, 0x81, 0x80, 0x4d, 0xd0, 0x00, 0xa0, 0xf0, 0x70, 0x3e, 0x80, 0x30, 0x20,
		0x35, 0x00, 0x55, 0x50, 0x21, 0x00, 0x00, 0x1a, 0x00, 0x00, 0x00, 0xfd, 0x00, 0x1d, 0x3c, 0x1c,
		0x87, 0x3c, 0x01, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x48,
		0x50, 0x20, 0x5a, 0x32, 0x37, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0xff,
		0x00, 0x43, 0x4e, 0x34, 0x38, 0x31, 0x38, 0x30, 0x33, 0x31, 0x4e, 0x0a, 0x20, 0x20, 0x01, 0xdb,
		0x02, 0x03, 0x24, 0xf1, 0x51, 0x61, 0x10, 0x04, 0x03, 0x02, 0x1f, 0x13, 0x12, 0x11, 0x5f, 0x05,
		0x14, 0x07, 0x06, 0x16, 0x15, 0x01, 0x23, 0x09, 0x07, 0x07, 0x83, 0x01, 0x00, 0x00, 0x65, 0x03,
		0x0c, 0x00, 0x10, 0x00, 0xa3, 0x66, 0x00, 0xa0, 0xf0, 0x70, 0x1f, 0x80, 0x30, 0x20, 0x35, 0x00,
		0x55, 0x50, 0x21, 0x00, 0x00, 0x1a, 0x02, 0x3a, 0x80, 0x18, 0x71, 0x38, 0x2d, 0x40, 0x58, 0x2c,
		0x45, 0x00, 0x55, 0x50, 0x21, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2f
		};


Cylon6::Cylon6 (CActLED *_m_ActLED, CTimer *_m_Timer)
:	CI2CSlave (I2C_SLAVE_ADDRESS, _m_Timer),
	GPIOPin (21, GPIOModeOutput)
{
	m_ActLED = _m_ActLED;
	m_Timer = _m_Timer;
}

Cylon6::~Cylon6 (void)
{
}

void Cylon6::Run (void)
{
	CLogger::Get() -> Write("Cylon-6", LogDebug, "Version 118");
	int count = 0;
	while(1)
	{
		CLogger::Get() -> Write("Cylon-6", LogDebug, "---- Test Case #%d", ++count);
		change_name_sn(edid, (char *)"Cylon6#", count);

		m_ActLED->Blink (1);	
		send_edid(edid);
		m_ActLED->Blink (2);	

		CLogger::Get() -> Write("Cylon-6", LogDebug, "---- Test Case #%d done ----", count);
		m_Timer->MsDelay (3000);
	}

}

void Cylon6::change_name_sn(u8 edid[], char *name, int count)
{

	char count_str[8] = {0};
	for(int i=0; i<8; i++)
	{
		count_str[7-i] = count >> ( i * 4 ) & 0xf;
		count_str[7-i] = count_str[7-i] >= 10 ? count_str[7-i] - 10 + 'A' : count_str[7-i] + '0';
	}

	// Vendor ==> shown in gnome-control-center
	// 2bytes, 15 in 16 bits used,  "LON" ==> 12 15 14 ==> 0 01100 01111 01110 ==> 00110001 11101110 ==> 0x31 0xee
	// We use "LON" here, if "LON" doesn't exist in /usr/share/hwdata/pnp.ids, then gnome-control-center only shows "LON"
	memset(edid + 0x08, 0x31, 1);
	memset(edid + 0x09, 0xee, 1);

	// Screen Size ==> shown in gnome-control-center
	// 2bytes, length and hight in cm
	memset(edid + 0x15, count*2, 1);
	memset(edid + 0x16, count*2, 1);

	// Serial Number
	memcpy(edid + 0x71, "SN", 2);
	memcpy(edid + 0x71 + 2, count_str, 8);


	// 0x5a ~ 0x6b: 0x00, 0x00, 0x00, 0xfc, 0x00, (13 Bytes left...)
	// Name + Count[4:]
	int tmp = strlen(name);
	if(tmp >= 8)
		tmp = 8;
	memcpy(edid + 0x5a + 5, name, tmp);
	memcpy(edid + 0x5a + 5 + tmp + 0, count_str+4, 4);
	memset(edid + 0x5a + 5 + tmp + 4, 0x0a, 1);

	// checksum
	tmp = 0;
	for (int i=0; i<127; i++)
		tmp += edid[i];
	edid[127] = 256 - (tmp % 256);
}

int Cylon6::send_edid(const u8 edid[])
{

	static u8 read_data[16] = {0};
	static u8 send_data[300] = {0};
	memcpy(send_data+1, edid, 256);
	GPIOPin.Write(1);

	static int ret=0;
	while (1)
	{
/* AMD	Read (read_data, 1);
		Write(edid, 9);		// Write(8) then Write(1) does not work, always left one more byte ahead of the real 128bytes edid.

		Read (read_data, 1);
		Read (read_data, 1);
		Write(edid, 128);

		Read (read_data, 1);
		Write(edid + 0x80, 128);
*/

/* Intel */
		// Write(1) does not work here, like above, left one more byte ahead of 128 bytes data.
		// memcpy(send_data+1, edid, 128);
		ret = Read (read_data, 1, 1);
		if(ret == -2)		// ret == -2, read timeout
			break;
		ret = Write(send_data, 129, 2);
		if(ret == -2)
			break;

		Read (read_data, 2, 1);
		Write(send_data + 1 + 0x80, 128, 2);
	}

	GPIOPin.Write(0);
	return 0;
}
